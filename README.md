# Marcos_GB-4-Prueba-de-Evaluacion-Continua-29-4-2024

Repositorio --> 


  ## **1. *Parte del mMdelo***
  
##### **[Modelo -->(https://github.com/MarckosBilbo/Tema8-RelacionesClases-MarcosGB/tree/main/src/main/java/Ej_1])**

Tenemos dentro del modulo java(source) esta el paquete uax.examen4.Halting_Problem que contiene el main y el paquete modelo vissta controlador (un paquete para cada uno).

-Dentro del paquete Modelo:  

-Tenemos las clases TipoSolicitud, Solicitud y Maquina Genereica (Ademas del Paquete MaquinasDeEstado)  

1ºTipoSolicitud: 
package uax.examen4.Halting_Problem.Modelo;  
/**  
Enumeración que representa los tipos de solicitudes que puede manejar la aplicación. */ public enum TipoSolicitud { ORDENAR,//Solcitud para ordenar una lista (MaquinaQueSeDetiene) IMPRIMIR_HORA//Solicitud para imprimir la hora actual (MaquinaEnBucle) }

2ºSolicitud: 

package uax.examen4.Halting_Problem.Modelo;  import java.time.LocalTime; import java.util.ArrayList; import java.util.Collections; import java.util.List;  /**  
Clase que representa una solicitud que puede ser de tipo ORDENAR o IMPRIMIR_HORA.  
Esta clase tiene un método ejecutar() que ejecuta la acción correspondiente al tipo de solicitud. */ public class Solicitud {  private static Solicitud instance = null;  private TipoSolicitud tipo; private List<integer> numeros;</integer>  
<pre>/** * Constructor privado de la clase Solicitud. * Este constructor es privado como parte de la implementación del patrón Singleton. * Las instancias de esta clase deben obtenerse a través de los métodos getInstance(). * * @param tipo El tipo de la solicitud. * @param numeros La lista de números a ordenar si el tipo de la solicitud es ORDENAR. */ private Solicitud(TipoSolicitud tipo, List<Integer> numeros) { this.tipo = tipo; this.numeros = numeros; } /** * Devuelve la única instancia de Solicitud, creándola si es necesario. * Este método es parte del patrón Singleton y garantiza que solo exista una instancia de Solicitud. * * @param tipo El tipo de la solicitud. * @param numeros La lista de números a ordenar si el tipo de la solicitud es ORDENAR. * @return La única instancia de Solicitud. */ public static Solicitud getInstance(TipoSolicitud tipo, List<Integer> numeros) { if (instance == null) { instance = new Solicitud(tipo, numeros); } return instance; } /** * Devuelve la única instancia de Solicitud, creándola si es necesario con valores predeterminados. * Este método es parte del patrón Singleton y garantiza que solo exista una instancia de Solicitud. * Si la instancia aún no ha sido creada, se creará una nueva instancia con TipoSolicitud.IMPRIMIR_HORA como tipo de solicitud y una lista vacía de números. * * @return La única instancia de Solicitud. */ public static Solicitud getInstance() { if (instance == null) { instance = new Solicitud(TipoSolicitud.IMPRIMIR_HORA, new ArrayList<>()); } return instance; } /** * Devuelve el tipo de la solicitud. * @return El tipo de la solicitud. */ public TipoSolicitud tipo() { return tipo; } /** * Devuelve los datos procesados por la solicitud. * @return La lista de números ordenada si el tipo de la solicitud es ORDENAR. */ public List<Integer> getDatos() { return numeros; } /** * Ejecuta la acción correspondiente al tipo de solicitud. */ public void ejecutar() { if (tipo == TipoSolicitud.ORDENAR) { ordenarNumeros(); } else if (tipo == TipoSolicitud.IMPRIMIR_HORA) { ejecutarComoReloj(); } } /** * Ordena la lista de números y la imprime. */ private void ordenarNumeros() { Collections.sort(numeros); System.out.println("Lista ordenada: " + numeros); } /** * Establece la hora actual como los datos de la solicitud almacenandola además. */ private void imprimirHora() { LocalTime horaActual = LocalTime.now(); this.numeros = Collections.singletonList(horaActual.getSecond()); } /** * Inicia un hilo que establece y almacena la hora actual cada segundo. */ public void ejecutarComoReloj() { if (tipo == TipoSolicitud.IMPRIMIR_HORA) { new Thread(() -> { while (true) { imprimirHora(); try { Thread.sleep(1000); // espera un segundo antes de la próxima actualización } catch (InterruptedException e) { Thread.currentThread().interrupt(); // restablece el estado interrumpido break; } } }).start(); } } </pre> }  

3ºMaquina Generica: 
package uax.examen4.Halting_Problem.Modelo;  /**  
Interfaz que define los métodos que deben implementar las máquinas en la aplicación. */ public interface MaquinaGenerica {
<pre>/** * Establece la siguiente máquina en la cadena de responsabilidad. * @param maquina La siguiente máquina. */ void setNext(MaquinaGenerica maquina); /** * Ejecuta una solicitud. * @param solicitud La solicitud a ejecutar. */ void ejecutarSolicitud(Solicitud solicitud); </pre> }



En ese mismo nivel tenemos el paquete Maquinas de estado que contiene otros 3 paques y una interfaz:

Paquetes(MaquinaEnBucle, MaquinaQueSeDetiene y Maquina check)  

1ºInterfaz(MaquinaFactory):  
package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica;  /**  
Interfaz que define un método para crear una nueva máquina. */ public interface MaquinaFactory {
<pre>/** * Crea una nueva máquina. * @return La nueva máquina. */ MaquinaGenerica crearMaquina(); </pre> }  
-Dentro de los paquetes Maquina en Bucle y Maquina que se detiene (hay dos clases que respaldan la interfaz factory) respectivamente una en cada paquete: 

-MaquinaBucleFact(paquete Maquinaenbucle): 

package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_En_Bucle;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaFactory;  /**  
Clase que implementa la interfaz MaquinaFactory y proporciona una implementación concreta del método crearMaquina().
Esta clase crea una nueva MaquinaEnBucle. */ public class MaquinaBucleFact implements MaquinaFactory {
<pre>/** * Crea una nueva instancia de MaquinaEnBucle. * @return una nueva instancia de MaquinaEnBucle. */ @Override public MaquinaGenerica crearMaquina() { return new MaquinaEnBucle(); } </pre> }  -

-MaquinaDetieneFact(paquete MaquinaQueSeDetiene): 

package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_QueSe_Detiene;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaFactory;  /**  
Clase que implementa la interfaz MaquinaFactory y proporciona una implementación concreta del método crearMaquina().
Esta clase crea una nueva MaquinaQueSeDetiene. */ public class MaquinaDetieneFact implements MaquinaFactory {
<pre>/** * Crea una nueva instancia de MaquinaQueSeDetiene. * @return una nueva instancia de MaquinaQueSeDetiene. */ @Override public MaquinaGenerica crearMaquina() { return new MaquinaQueSeDetiene(); } </pre> }




Por ultimo Dentro de estos 3 paquetes (MaquinaEnBucle, MaquinaQueSeDetiene y Maquina check) hay clases restantes que debería mostrar: 

 Paquete MaquinaEnBucle:  

-Clase MaquinaEnblucle: 

package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_En_Bucle;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica; import uax.examen4.Halting_Problem.Modelo.Solicitud; import uax.examen4.Halting_Problem.Modelo.TipoSolicitud;  /**  
Clase que implementa la interfaz MaquinaGenerica y proporciona implementaciones concretas de los métodos setNext(MaquinaGenerica maquina) y ejecutarSolicitud(Solicitud solicitud).  
Esta clase ejecuta una solicitud si es de tipo IMPRIMIR_HORA y delega la solicitud a la siguiente máquina en la cadena si no lo es. */ public class MaquinaEnBucle implements MaquinaGenerica {  private MaquinaGenerica next;  
<pre>/** * Establece la siguiente máquina en la cadena de responsabilidad. * @param maquina la siguiente máquina. */ @Override public void setNext(MaquinaGenerica maquina) { this.next = maquina; } /** * Ejecuta la solicitud si es de tipo IMPRIMIR_HORA, de lo contrario, delega la solicitud a la siguiente máquina en la cadena. * @param solicitud la solicitud a ejecutar. */ @Override public void ejecutarSolicitud(Solicitud solicitud) { if (solicitud.tipo() == TipoSolicitud.IMPRIMIR_HORA) { solicitud.ejecutar(); } else if (next != null) { next.ejecutarSolicitud(solicitud); } } </pre> }package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_En_Bucle;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica; import uax.examen4.Halting_Problem.Modelo.Solicitud; import uax.examen4.Halting_Problem.Modelo.TipoSolicitud;  /**  
Clase que implementa la interfaz MaquinaGenerica y proporciona implementaciones concretas de los métodos setNext(MaquinaGenerica maquina) y ejecutarSolicitud(Solicitud solicitud).  
Esta clase ejecuta una solicitud si es de tipo IMPRIMIR_HORA y delega la solicitud a la siguiente máquina en la cadena si no lo es. */ public class MaquinaEnBucle implements MaquinaGenerica {  private MaquinaGenerica next;  
<pre>/** * Establece la siguiente máquina en la cadena de responsabilidad. * @param maquina la siguiente máquina. */ @Override public void setNext(MaquinaGenerica maquina) { this.next = maquina; } /** * Ejecuta la solicitud si es de tipo IMPRIMIR_HORA, de lo contrario, delega la solicitud a la siguiente máquina en la cadena. * @param solicitud la solicitud a ejecutar. */ @Override public void ejecutarSolicitud(Solicitud solicitud) { if (solicitud.tipo() == TipoSolicitud.IMPRIMIR_HORA) { solicitud.ejecutar(); } else if (next != null) { next.ejecutarSolicitud(solicitud); } } </pre> }  

-Paquete (MaquinaQueSeDetien):  

Clase MaquinaQueSeDetiene:

 package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_QueSe_Detiene;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica; import uax.examen4.Halting_Problem.Modelo.Solicitud; import uax.examen4.Halting_Problem.Modelo.TipoSolicitud;  /**  
Clase que implementa la interfaz MaquinaGenerica y proporciona implementaciones concretas de los métodos setNext(MaquinaGenerica maquina) y ejecutarSolicitud(Solicitud solicitud).  
Esta clase ejecuta una solicitud si es de tipo ORDENAR y delega la solicitud a la siguiente máquina en la cadena si no lo es. */ public class MaquinaQueSeDetiene implements MaquinaGenerica {  private MaquinaGenerica next;  
<pre>/** * Establece la siguiente máquina en la cadena de responsabilidad. * @param maquina la siguiente máquina. */ @Override public void setNext(MaquinaGenerica maquina) { this.next = maquina; } /** * Ejecuta la solicitud si es de tipo ORDENAR, de lo contrario, delega la solicitud a la siguiente máquina en la cadena. * @param solicitud la solicitud a ejecutar. */ @Override public void ejecutarSolicitud(Solicitud solicitud) { if (solicitud.tipo() == TipoSolicitud.ORDENAR) { solicitud.ejecutar(); } else if (next != null) { next.ejecutarSolicitud(solicitud); } } </pre> }  


-Paquete (MaquinaCheck):  

1ºClase EstadoMaquina:

 package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaCheck;  /**  
Enumeración que representa los posibles estados de una máquina. */ public enum EstadoMaquina { SE_DETINE,//Determina si la máquina se detiene EN_BUCLE//Determina si la máquina entra en un bucle infinito }


2ºClase MaquinaCheck: 

package uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaCheck;  import uax.examen4.Halting_Problem.Modelo.MaquinaGenerica; import uax.examen4.Halting_Problem.Modelo.Solicitud; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_En_Bucle.MaquinaEnBucle; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_QueSe_Detiene.MaquinaQueSeDetiene;  /**  
Clase que implementa la interfaz MaquinaGenerica y proporciona una implementación concreta del método ejecutarSolicitud(Solicitud solicitud).  
Esta clase recibe una máquina, determina si se detiene o entra en un bucle infinito basándose en el tipo de la máquina, y almacena ese estado. */ public class MaquinaCheck implements MaquinaGenerica {  private MaquinaGenerica maquina; private EstadoMaquina estado;  
<pre>/** * Constructor de la clase MaquinaCheck. * @param maquina La máquina que se va a verificar si se detiene o entra en un bucle infinito. */ public MaquinaCheck(MaquinaGenerica maquina) { this.maquina = maquina; } /** * Devuelve el estado de la máquina. * @return el estado de la máquina. */ public EstadoMaquina getEstado() { return estado; } /** * Este método no se utiliza en esta clase ya que MaquinaCheck no delega responsabilidades a otras máquinas. * @param maquina La máquina a la que se delegaría la responsabilidad, si se utilizara este método. */ @Override public void setNext(MaquinaGenerica maquina) { // Esta máquina no delega responsabilidades. } /** * Ejecuta la solicitud en la máquina proporcionada, determina si se detiene o entra en un bucle infinito basándose en el tipo de la máquina, y almacena ese estado. * @param solicitud la solicitud a ejecutar. */ @Override public void ejecutarSolicitud(Solicitud solicitud) { // Ejecuta la solicitud en la máquina proporcionada maquina.ejecutarSolicitud(solicitud); // Determina estado 'Halting' o 'Looping' basándose en el tipo de la máquina if (maquina instanceof MaquinaQueSeDetiene) { estado = EstadoMaquina.SE_DETINE; } else if (maquina instanceof MaquinaEnBucle) { estado = EstadoMaquina.EN_BUCLE; } } </pre> }

  ## **2. *Parte de Controlador***

##### **[Controlador -->(https://github.com/MarckosBilbo/Tema8-RelacionesClases-MarcosGB/tree/main/src/main/java/Ej_2])**

Vamos ahora con el paquete Controlador:  

-Clase ControladorGenerico: 

package uax.examen4.Halting_Problem.Controlador;  import javafx.fxml.FXML; import javafx.scene.control.Button; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaCheck.EstadoMaquina; import uax.examen4.Halting_Problem.Modelo.Solicitud; import uax.examen4.Halting_Problem.Modelo.TipoSolicitud; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaCheck.MaquinaCheck; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_En_Bucle.MaquinaEnBucle; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.Maquina_QueSe_Detiene.MaquinaQueSeDetiene; import java.util.List;  /**  
Controlador genérico para la aplicación.  
Este controlador maneja las acciones de los botones y la lógica de la máquina de verificación. */ public class ControladorGenerico {  @FXML private Button botonOrdenar;  @FXML private Button botonImprimirHora;  private MaquinaCheck maquinaCheck;  
<pre>/** * Constructor del controlador genérico. * Inicializa la máquina de verificación con una máquina que se detiene y establece la siguiente máquina en la cadena de responsabilidad como una máquina en bucle. */ public ControladorGenerico() { maquinaCheck = new MaquinaCheck(new MaquinaQueSeDetiene()); maquinaCheck.setNext(new MaquinaEnBucle()); } /** * Ordena una lista de números. * Crea y ejecuta una solicitud de tipo ORDENAR. * @param numeros La lista de números a ordenar. */ @FXML public void ordenar(List<Integer> numeros) { Solicitud solicitud = Solicitud.getInstance(TipoSolicitud.ORDENAR, numeros); maquinaCheck.ejecutarSolicitud(solicitud); } /** * Imprime la hora actual. * Crea y ejecuta una solicitud de tipo IMPRIMIR_HORA. */ @FXML public void imprimirHora() { Solicitud solicitud = Solicitud.getInstance(TipoSolicitud.IMPRIMIR_HORA, null); maquinaCheck.ejecutarSolicitud(solicitud); } /** * Obtiene el veredicto de la máquina de verificación. * @return El estado de la máquina de verificación. */ public EstadoMaquina obtenerVeredicto() { return maquinaCheck.getEstado(); } </pre> }


   ## **3. *Parte de la Vista***

##### **[Vista -->(https://github.com/MarckosBilbo/Tema8-RelacionesClases-MarcosGB/tree/main/src/main/java/Ej_3])**



Y dentro del paquete Vista una unica clase:

 VistaGlobal: 

package uax.examen4.Halting_Problem.Vista;  import javafx.animation.KeyFrame; import javafx.animation.Timeline; import javafx.application.Application; import javafx.geometry.Pos; import javafx.scene.Node; import javafx.scene.Scene; import javafx.scene.control.Button; import javafx.scene.control.Label; import javafx.scene.layout.GridPane; import javafx.scene.layout.HBox; import javafx.scene.layout.VBox; import javafx.stage.Stage; import javafx.util.Duration; import uax.examen4.Halting_Problem.Controlador.ControladorGenerico; import uax.examen4.Halting_Problem.Modelo.Maquinas_De_Estado.MaquinaCheck.EstadoMaquina; import uax.examen4.Halting_Problem.Modelo.Solicitud; import java.time.LocalTime; import java.time.format.DateTimeFormatter; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors;  public class VistaGlobal extends Application {  <pre>private ControladorGenerico controlador = new ControladorGenerico(); private List<Integer> numeros = new ArrayList<>(); private Label display = new Label(); private Solicitud solicitud = Solicitud.getInstance(); @Override public void start(Stage primaryStage) { Button btnImprimirHora = new Button("Imprimir Hora"); btnImprimirHora.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 103px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnImprimirHora.setOnMouseEntered(event -> btnImprimirHora.setStyle("-fx-background-color: #45a049; -fx-text-fill: white; -fx-font-size: 103px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnImprimirHora.setOnMouseExited(event -> btnImprimirHora.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 103px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnImprimirHora.setMaxHeight(Double.MAX_VALUE); btnImprimirHora.setOnAction(event -> { solicitud.ejecutarComoReloj(); primaryStage.setScene(crearEscenaReloj()); }); Button btnOrdenamiento = new Button("Ordenamiento"); btnOrdenamiento.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnOrdenamiento.setOnMouseEntered(event -> btnOrdenamiento.setStyle("-fx-background-color: #45a049; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnOrdenamiento.setOnMouseExited(event -> btnOrdenamiento.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnOrdenamiento.setMaxHeight(Double.MAX_VALUE); btnOrdenamiento.setOnAction(event -> primaryStage.setScene(crearEscenaTeclado(primaryStage))); VBox rootInicial = new VBox(btnImprimirHora, btnOrdenamiento); rootInicial.setAlignment(Pos.CENTER); // Centrar los elementos en el VBox rootInicial.setStyle("-fx-padding: 24px; -fx-spacing: 12px;"); Scene escenaInicial = new Scene(rootInicial, 850, 700); primaryStage.setTitle("Halting Problem"); primaryStage.setScene(escenaInicial); primaryStage.show(); } private Scene crearEscenaTeclado(Stage primaryStage) { GridPane teclado = new GridPane(); for (int i = 0; i < 10; i++) { Button btn = new Button(String.valueOf(i)); btn.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 35px; -fx-border-color: black;"); btn.setOnAction(event -> { display.setText(btn.getText()); display.setStyle("-fx-font-size: 50px; -fx-text-fill: #333;"); }); teclado.add(btn, i % 10, i /10); teclado.setAlignment(Pos.CENTER); } Button btnIntroducir = new Button("Introducir"); btnIntroducir.setStyle("-fx-background-color: Black; -fx-text-fill: white; -fx-font-size: 60px; -fx-border-color: white; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnIntroducir.setOnMouseEntered(event -> btnIntroducir.setStyle("-fx-background-color: gray; -fx-text-fill: white; -fx-font-size: 60px; -fx-border-color: white; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnIntroducir.setOnMouseExited(event -> btnIntroducir.setStyle("-fx-background-color: Black; -fx-text-fill: white; -fx-font-size: 60px; -fx-border-color: white; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnIntroducir.setOnAction(event -> { numeros.add(Integer.parseInt(display.getText())); display.setText(""); }); Button btnOrdenar = new Button("Ordenar"); btnOrdenar.setStyle("-fx-background-color: Black; -fx-text-fill: white; -fx-font-size: 60px; -fx-border-color: white; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnOrdenar.setOnMouseEntered(event -> btnOrdenar.setStyle("-fx-background-color: gray; -fx-text-fill: white; -fx-font-size: 60px; -fx-border-color: white; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnOrdenar.setOnMouseExited(event -> btnOrdenar.setStyle("-fx-background-color: Black; -fx-text-fill: white; -fx-font-size: 60px; -fx-border-color: white; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnOrdenar.setOnAction(event -> { controlador.ordenar(numeros); primaryStage.setScene(crearEscenaListaOrdenada(primaryStage)); }); HBox botones = new HBox(btnIntroducir, btnOrdenar); botones.setAlignment(Pos.CENTER); // Centrar los elementos en el HBox botones.setSpacing(12); VBox rootTeclado = new VBox(display, teclado, botones); rootTeclado.setAlignment(Pos.CENTER); // Centrar los elementos en el VBox rootTeclado.setStyle("-fx-padding: 24px; -fx-spacing: 12px;"); Scene escenaTeclado = new Scene(rootTeclado, 850, 700); return escenaTeclado; } private Scene crearEscenaListaOrdenada(Stage primaryStage) { List<String> numerosOrdenados = numeros.stream() .sorted() .map(String::valueOf) .collect(Collectors.toList()); // Crear una cadena de texto con el formato deseado String numerosOrdenadosStr = numerosOrdenados.stream() .collect(Collectors.joining(", ", "[", "]")); HBox root = new HBox(); root.setAlignment(Pos.CENTER); // Agregar la cadena de texto a la interfaz gráfica Label labelNumeros = new Label(numerosOrdenadosStr); labelNumeros.setStyle("-fx-font-size: 100px; -fx-text-fill: #333; -fx-font-family: 'Calisto MT';"); root.getChildren().add(labelNumeros); Button btnVeredicto = new Button("Veredicto"); btnVeredicto.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 120px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnVeredicto.setOnMouseEntered(event -> btnVeredicto.setStyle("-fx-background-color: #45a049; -fx-text-fill: white; -fx-font-size: 120px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnVeredicto.setOnMouseExited(event -> btnVeredicto.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 120px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnVeredicto.setMaxHeight(Double.MAX_VALUE); btnVeredicto.setOnAction(event -> { primaryStage.setScene(crearEscenaVeredicto()); numeros.clear(); }); VBox vbox = new VBox(root, btnVeredicto); vbox.setAlignment(Pos.CENTER); // Centrar los elementos en el VBox vbox.setStyle("-fx-padding: 24px; -fx-spacing: 12px;"); Scene escenaListaOrdenada = new Scene(vbox, 850, 700); return escenaListaOrdenada; } private Scene crearEscenaVeredicto() { EstadoMaquina estado = controlador.obtenerVeredicto(); Label label; if (estado == EstadoMaquina.SE_DETINE) { label = new Label("-El programa se detiene 'Halting'"); } else if (estado == EstadoMaquina.EN_BUCLE) { label = new Label("-El programa entra en un bucle 'Looping'"); } else { label = new Label("Estado desconocido"); } label.setStyle("-fx-font-size: 40px; -fx-text-fill: #333; -fx-font-family: 'Consolas';"); Button btnCerrar = new Button("Cerrar"); btnCerrar.setStyle("-fx-background-color: red; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnCerrar.setOnMouseEntered(event -> btnCerrar.setStyle("-fx-background-color: lightcoral; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnCerrar.setOnMouseExited(event -> btnCerrar.setStyle("-fx-background-color: red; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnCerrar.setMaxHeight(Double.MAX_VALUE); btnCerrar.setOnAction(event -> System.exit(0)); Button btnInicio = new Button("Inicio"); btnInicio.setStyle("-fx-background-color: blue; -fx-text-fill: white; -fx-font-size: 108px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnInicio.setOnMouseEntered(event -> btnInicio.setStyle("-fx-background-color: lightblue; -fx-text-fill: white; -fx-font-size: 108px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnInicio.setOnMouseExited(event -> btnInicio.setStyle("-fx-background-color: blue; -fx-text-fill: white; -fx-font-size: 108px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnInicio.setMaxHeight(Double.MAX_VALUE); btnInicio.setOnAction(event -> start(new Stage())); VBox root = new VBox(label, btnCerrar, btnInicio); root.setAlignment(Pos.CENTER); // Centrar los elementos en el VBox root.setStyle("-fx-padding: 24px; -fx-spacing: 12px;"); Scene escenaVeredicto = new Scene(root, 850, 700); return escenaVeredicto; } private Scene crearEscenaReloj() { Label labelHora = new Label(); labelHora.setStyle("-fx-font-size: 75px; -fx-text-fill: #333;"); // Crear un Timeline que se ejecuta cada segundo Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1), event -> { // Obtener la hora actual y mostrarla en el label LocalTime horaActual = LocalTime.now(); DateTimeFormatter formatter = DateTimeFormatter.ofPattern("/-/ HH:mm:ss /-/"); labelHora.setText(horaActual.format(formatter)); })); timeline.setCycleCount(Timeline.INDEFINITE); timeline.play(); Button btnVeredicto = new Button("Veredicto"); btnVeredicto.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 120px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnVeredicto.setOnMouseEntered(event -> btnVeredicto.setStyle("-fx-background-color: #45a049; -fx-text-fill: white; -fx-font-size: 120px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnVeredicto.setOnMouseExited(event -> btnVeredicto.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-size: 120px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnVeredicto.setOnAction(event -> { // Cambiar a la escena del veredicto Stage primaryStage = (Stage) ((Node) event.getSource()).getScene().getWindow(); primaryStage.setScene(crearEscenaVeredictoReloj()); }); VBox root = new VBox(labelHora, btnVeredicto); root.setAlignment(Pos.CENTER); // Centrar los elementos en el VBox root.setStyle("-fx-padding: 24px; -fx-spacing: 12px;"); Scene escenaReloj = new Scene(root, 850, 700); return escenaReloj; } private Scene crearEscenaVeredictoReloj() { Label label = new Label("-El programa nunca se detiene 'Looping'"); label.setStyle("-fx-font-size: 37px; -fx-text-fill: #333; -fx-font-family: 'Consolas';"); Button btnCerrar = new Button("Cerrar"); btnCerrar.setStyle("-fx-background-color: red; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnCerrar.setOnMouseEntered(event -> btnCerrar.setStyle("-fx-background-color: lightcoral; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnCerrar.setOnMouseExited(event -> btnCerrar.setStyle("-fx-background-color: red; -fx-text-fill: white; -fx-font-size: 100px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnCerrar.setMaxHeight(Double.MAX_VALUE); btnCerrar.setOnAction(event -> System.exit(0)); Button btnInicio = new Button("Inicio"); btnInicio.setStyle("-fx-background-color: blue; -fx-text-fill: white; -fx-font-size: 108px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;"); btnInicio.setOnMouseEntered(event -> btnInicio.setStyle("-fx-background-color: lightblue; -fx-text-fill: white; -fx-font-size: 108px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnInicio.setOnMouseExited(event -> btnInicio.setStyle("-fx-background-color: blue; -fx-text-fill: white; -fx-font-size: 108px; -fx-border-color: black; -fx-border-width: 10px; -fx-border-radius: 60px; -fx-background-radius:63px;")); btnInicio.setMaxHeight(Double.MAX_VALUE); btnInicio.setOnAction(event -> start(new Stage())); VBox root = new VBox(label, btnCerrar, btnInicio); root.setAlignment(Pos.CENTER); // Centrar los elementos en el VBox root.setStyle("-fx-padding: 24px; -fx-spacing: 12px;"); Scene escenaVeredictoReloj = new Scene(root, 850, 700); return escenaVeredictoReloj; } </pre> }

